#!/usr/bin/env node
/**
 * create-issues-from-changelog.mjs
 * @since 2025-10-28
 * @version 1.0.0
 * Summary: Create GitHub issues from changelog sections with guardrails.
 */

import path from "node:path";
import { z } from "zod";
import {
  parseFlags,
  Logger,
  repoRoot,
  fail,
  succeed,
  generateRunId,
} from "../_lib/core.mjs";
import {
  parseChangelogFile,
  filterChangelogByVersion,
  laneLabelFromTitle,
  normalizeSectionFilters,
  extractSections,
} from "../_lib/changelog.mjs";
import { createIssue, isGhAuthenticated } from "../_lib/github.mjs";

const SCRIPT_NAME = "create-issues-from-changelog";
const start = Date.now();
const rawArgs = parseFlags(process.argv.slice(2));

if (rawArgs.help) {
  printHelp();
  process.exit(0);
}

const ArgsSchema = z.object({
  version: z.string().optional(),
  filter: z.string().optional(),
  dryRun: z.boolean().default(true),
  yes: z.boolean().default(false),
  output: z.enum(["text", "json"]).default("text"),
  logLevel: z.enum(["trace", "debug", "info", "warn", "error"]).default("info"),
  cwd: z.string().min(1),
  changelog: z.string().default("CHANGELOG.md"),
  assign: z.boolean().default(false),
  max: z.number().int().positive().optional(),
});

const argsForValidation = {
  version: rawArgs.version,
  filter: rawArgs.filter,
  dryRun: coerceBoolean(rawArgs.dryRun, true),
  yes: coerceBoolean(rawArgs.yes, false),
  output: rawArgs.output,
  logLevel: rawArgs.logLevel,
  cwd: rawArgs.cwd || process.cwd(),
  changelog: rawArgs.changelog,
  assign: coerceBoolean(rawArgs.assign, false),
  max: rawArgs.max ? Number(rawArgs.max) : undefined,
};

const parsed = ArgsSchema.safeParse(argsForValidation);
if (!parsed.success) {
  fail({
    exitCode: 11,
    message: "validation_error",
    error: parsed.error.format(),
    output: rawArgs.output || "text",
    script: SCRIPT_NAME,
  });
}

const args = parsed.data;
const logger = new Logger(args.logLevel);
const runId = generateRunId();

async function main() {
  const root = await repoRoot(args.cwd);
  const changelogPath = path.resolve(root, args.changelog);
  logger.info(`Using changelog: ${path.relative(root, changelogPath)}`);

  const entries = await parseChangelogFile(changelogPath);
  const targetEntries = filterChangelogByVersion(entries, args.version);
  if (targetEntries.length === 0) {
    reportNoEntries(args.version);
  }

  const filters = normalizeSectionFilters(args.filter);
  const sections = extractSections(targetEntries, filters);
  if (sections.length === 0) {
    reportNoMatches(filters);
  }

  const limitedSections = applyLimit(sections, args.max);
  if (!args.dryRun) {
    await ensureGhReady();
  }

  const results = await processSections(limitedSections, root);
  finalizeRun(limitedSections.length, results);
}

main().catch((error) => {
  fail({
    exitCode: 13,
    message: "unexpected_error",
    error: error instanceof Error ? error.message : String(error),
    output: args.output,
    script: SCRIPT_NAME,
  });
});

function coerceBoolean(value, defaultValue) {
  if (value === undefined || value === null) return defaultValue;
  if (typeof value === "boolean") return value;
  const normalized = String(value).toLowerCase();
  if (["false", "0", "no"].includes(normalized)) return false;
  if (["true", "1", "yes"].includes(normalized)) return true;
  return defaultValue;
}

function buildIssueBody(section) {
  const lines = [];
  lines.push(section.content.trim());
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push(`**Source Version:** ${section.version}`);
  if (section.date) {
    lines.push(`**Released:** ${section.date}`);
  }
  lines.push("**Generated By:** scripts/ops/create-issues-from-changelog.mjs");
  return lines.join("\n");
}

function applyLimit(sections, max) {
  if (!max || max <= 0) return sections;
  return sections.slice(0, max);
}

async function ensureGhReady() {
  const authenticated = await isGhAuthenticated();
  if (!authenticated) {
    fail({
      exitCode: 10,
      message: "precondition_failed",
      error: "GitHub CLI not authenticated. Run `gh auth login`.",
      output: args.output,
      script: SCRIPT_NAME,
    });
  }
}

async function processSections(sections, root) {
  const results = [];

  for (const section of sections) {
    const issueTitle = section.title;
    const issueBody = buildIssueBody(section);
    const laneLabel = laneLabelFromTitle(section.title);
    const labels = laneLabel ? [laneLabel] : [];

    if (args.dryRun) {
      logger.info(`[DRY-RUN] ${issueTitle}`);
      results.push({
        title: issueTitle,
        labels,
        version: section.version,
        dryRun: true,
      });
      continue;
    }

    try {
      const url = await createIssue(
        issueTitle,
        issueBody,
        args.assign,
        labels,
        root,
      );
      const number = url.split("/").pop();
      logger.info(`Created issue #${number} (${issueTitle})`);
      results.push({
        title: issueTitle,
        labels,
        version: section.version,
        url,
        number,
        dryRun: false,
      });
    } catch (error) {
      logger.error(
        `Failed to create issue for ${issueTitle}: ${error.message}`,
      );
      results.push({
        title: issueTitle,
        labels,
        version: section.version,
        error: error.message,
        dryRun: false,
      });
    }
  }

  return results;
}

function finalizeRun(sectionCount, results) {
  const created = results.filter((r) => !r.dryRun && !r.error).length;
  const failed = results.filter((r) => r.error).length;

  if (!args.dryRun && failed === sectionCount) {
    fail({
      exitCode: 11,
      message: "issue_creation_failed",
      error: results,
      output: args.output,
      script: SCRIPT_NAME,
    });
  }

  succeed({
    output: args.output,
    script: SCRIPT_NAME,
    runId,
    dryRun: args.dryRun,
    version: args.version ?? null,
    sectionsProcessed: sectionCount,
    issuesCreated: created,
    failures: failed,
    results,
    durationMs: Date.now() - start,
  });
}

function reportNoEntries(version) {
  succeed({
    output: args.output,
    script: SCRIPT_NAME,
    runId,
    dryRun: true,
    noop: true,
    message: version
      ? `No changelog entries found for version ${version}`
      : "No changelog entries found",
    durationMs: Date.now() - start,
  });
}

function reportNoMatches(filters) {
  const message = filters.length
    ? "No changelog sections matched the provided filter"
    : "No changelog sections available";

  succeed({
    output: args.output,
    script: SCRIPT_NAME,
    runId,
    dryRun: true,
    noop: true,
    message,
    durationMs: Date.now() - start,
  });
}

function printHelp() {
  console.log(`
Create GitHub issues from changelog sections

Usage:
  node scripts/ops/${SCRIPT_NAME}.mjs [options]

Options:
  --version <semver>     Only process a specific version
  --filter <text>        Comma-separated substring filter for section titles
  --max <n>              Limit number of sections to process
  --changelog <path>     Path to changelog file (default: CHANGELOG.md)
  --assign               Assign created issues to @me
  --yes                  Execute (disable dry-run)
  --dry-run              Preview without creating issues (default)
  --output <mode>        text|json output formatting (default: text)
  --log-level <level>    trace|debug|info|warn|error (default: info)
  --cwd <path>           Working directory (default: current)
  --help                 Show this help message

Exit codes:
  0  Success
  2  No matching sections
  10 Precondition failed (gh CLI not authenticated)
  11 Validation failed / Issue creation failed
  13 Unexpected error
`);
}
